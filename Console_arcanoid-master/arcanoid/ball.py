from arcanoid.base_object import BaseObject

class Ball(BaseObject):
    """Класс мяча"""
    def __init__(self, x: int, y: int, period: int):
        """
        Создаёт экземпляр мяча.

        Args:
            x (int): x-координата мяча.
            y (int): y-координата мяча.
            period (int): период, в течение которого мяч не движется. Чем он больше, тем медленнее мяч.
        """
        super().__init__(x, y, "O") # вызываем конструктор родительского класса
        self.dx = 0 #проекция вектора направления на ось OX
        self.dy = 0 #проекция вектора направления по оси OY (изначально мяч сам не движется)
        self.period = period #период ожидания. Экран перерисовывается очень часто, и на каждое перерисовывание вызывается метод движения мяча
        # получается, что мяч будет двигаться слишком быстро. Поэтому мы ограничиваем мяч в движении, указывая,
        # что он будет двигаться лишь 1 раз из period, таким образом, мы замедляем его в period раз.     
        self.current_stage = 0 # счётчик, который будет считать, когда период ожидания
        self.is_dead = False # флаг, говорящий о том, активен ли мяч. False -активен, True - Упал ниже платформы.

    def __str__(self) -> str:
        """
        Возвращает строковое представление объекта. Вызывается при приведении объекта к типу str.

        Returns:
            str: строковое представление объекта.
        """
        return self.sym
    
    def check_for_bounds(self, x_lim:int) -> None:
        """
        Проверяет, достиг ли мяч границ игрового поля и изменяет направление движения мяча.

        Args:
            x_lim (int): x-координата правой стенки игровой области.
        """
        if self.x+self.dx>=x_lim or self.x+self.dx<0: #если координата мяча после его следующего движения выйдет за границы игрового поля слева или справа
                self.dx = -self.dx # то меняем его направление по оси OX на противоположное. Если летел в правую сторону - полетит в левую
        if self.y+self.dy<0: # если на следующем шаге выйдет за потолок,
                self.dy = -self.dy # то меняем направление по OY

    def move(self, x_lim: int, y_lim: int) -> None:
        """
        Метод движения мяча. Меняет координаты мяча, если прошёл период ожидания.

        Args:
            x_lim (int): x-координата правой стенки игровой области.
            y_limit (int): y-координата, ниже которой мяч считается утраченным.
        """
        if not self.is_dead: # если мяч ещё активен
            self.check_for_bounds(x_lim) # проверяем, не столкнётся ли со стенками
            self.x+=self.dx*(self.current_stage//(self.period-1)) # меняем x-координату на величину dx в том случае, если период ожидания закончился.
            self.y+=self.dy*(self.current_stage//(self.period-1)) # то же самое с y-координатой.
            # self.current_stage//(self.period-1) равно 1 только когда период ожидания закончен. Во всех иных случаях равен 0,
            # поэтому, пока период ожидания не окончен, dx и dy будет умножаться на 0, то есть, координаты мяча не меняются
            self.current_stage = (self.current_stage+1)%self.period # увеличиваем счётчик и берём остаток от периода. Счётчик обнуляется каждый раз, как заканчивается период.
            if not self.current_stage: # если счётчик равен 0 (период был завершён => мяч сдвинулся)
                self.check_for_bounds(x_lim) #проверяем на выход за стены
                self.observer.notice(self) #уведомляем наблюдателя о движении мяча, передавая сам объект мяча
            if self.y == y_lim: #Если мяч упал на нижнюю границу, 
                self.is_dead = True #то он потерян
                self.sym=" " #обнуляем его символ

    def get_pixels_coordinates(self) -> tuple[int, int]:
        """
        Возвращает координаты символа мяча.

        Returns:
            tuple[int, int]: кортеж, представляющий координаты символа мяча: (x, y).
        """
        return (self.x, self.y)